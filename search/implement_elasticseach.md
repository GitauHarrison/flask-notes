# Implement Search Functionality In Your Flask App

[Elasticsearch](https://www.elastic.co/what-is/elasticsearch) may mean different things to different people, depending on their level of familiarity with the technology. At its core, Elasticsearch is largely a distributed open-source search and analytics engine for all types of data built on Apache Lucene and developed in Java, using NoSQL, meaning it stores data in unstructured way and that we cannot use SQL to query it. It is at the heart of the ELK Stack (Elasticsearch, Kibana and Logtash) such that it has become synonymous with the name of the stack itself. 

The following are other sections in the Elasticsearch series. You can click on any of the links to learn more:

- [Install Elasticsearch in Ubuntu 20.04 In Localhost](install_elasticsearch_localhost.md)
- [Install And Configure ElasticSearch In A Live Linux Server](install_elasticsearch_linode.md)
- [Implement Search Functionality In Your Flask App](implement_elasticseach.md) (this article)

As you learnt in the [installation guide](install_elasticsearch_localhost.md), support for full text search is not standardized like relational databases are. Also, the fact that SQLAlchemy does not natively support the search functionality, we have to contend with the fact that we need to manually do this ourselves.

### Table of Contents

- [Overview](#overview)
    - [Documents](#documents)
    - [Indices](#indices)
    - [Inverted index](#inverted-index)
    - [Cluster](#cluster)
    - [Nodes](#nodes)
    - [Shards](#shards)
- [Build A Simple Flask App](#build-a-simple-flask-app)


## Overview

From the [Testing](install_elasticsearch_localhost.md#testing) section in the Localhost installation guide, you saw how to index a document and get corresponding JSON data back. However, you may be curious to understand how everything actually works. The [Elasticsearch documenation](https://www.elastic.co/what-is/elasticsearch) does a good job of trying to explain how indexing and parsing works. Let us cover some basic concepts of how it organizes data and its backend components.

### Documents

They are the basic unit of JSON data that can be indexed in Elasticsearch. If you have interacted with rows in relational databases, a document is more less like a row object. Each document has a unique ID and a given data type.

```python
body={'test': 'this is the first test'}
```

### Indices

An index is used to classify documents that have the same characteristics. It is what you would typically use to query against Elasticsearch to retrieve logically-related data. Say you have a blog, you can have an index for Articles, another for Comments et cetera. Each index has a name.

```python
index='test_index'
```

### Inverted Index

Elasticsearch uses a data structure called an inverted index that supports very fast full-text searches. An inverted index lists every unique word that appears in any document and identifies all of the documents each word occurs in. Let us look at this example to best understand what it is.

![Inverted index](/images/elasticsearch/inverted_index.png)

The inverted index does not really store items directly, but it instead splits each documents up into individual search terms and then maps each term to the documents they occur in. By using inverted indices, Elasticsearch can quickly find best matches for full-text searches from even large data sets.

When performing full-text searches, we are actually querying an inverted index and not the JSON documents that we defined when indexing the documents. A cluster can have at least one inverted index. Thatâ€™s because there will be an inverted index for each full-text field per index. So if you have an index containing documents that contain five full-text fields, you will have five inverted indices.

### Cluster

A cluster is a group of one or more node instances that are connected together. The effectiveness of Elasticsearch is in the distribution of tasks to each node in the cluster.

### Nodes

A node is a single server that participates in the indexing and search capabilities of a cluster. 

- **Master node**: Responsible for cluster-wide operations such as creating and deleting an index and adding or remove a node
- **Data node**: Stores data and executes data related operations such as search and aggregation
- **Client node**: Forwards cluster requests to **master** and **data** nodes

### Shards

It is possible to subdivide an index into multiple pieces called shards. Each shard is a full-functional and independent index that can be hosted on any node. By distributing documents across many shards and distributing those shards across multiple nodes, Elasticsearch is able to protect against hardware failures and increase query capacities as nodes are added to a cluster. 

## Build A Simple Flask App

We are going to search data generated by users in an app. We, therefore, need to store these user data in a database against which we shall query. This section presumes you are already familiar with working with databases as we will not go into details of how to set up the application. You can refer to [this completed project on GitHub](https://github.com/GitauHarrison/search-functionality-in-flask). 

![Sample project](/images/elasticsearch/sample_project.png)

The key things that your application will need to have are:
- A model or models used to store user data (`Post` model has been used in the sample project)
- A form that allows users to post something
- A page that displayes all the data users posted in the app

Your navigation bar does not necessarily need to have a search form as seen in the image above. In a section below, we will learn how to add one such that it will available across all web pages of the app.


## Understanding Elasticsearch

In the [localhost installation guide](install_elasticsearch_localhost.md), you learnt how to install and configure Elasticsearch. We will need the Python client library while managing it, so make sure you install it in your virtual environment too:

```python
(venv)$ pip3 install elasticsearch && pip3 freeze > requirements.txt
```

The first thing we need to do is to connect to Elasticsearch:

```python
(venv) flask shell


>>> from elasticsearch import Elasticsearch
>>> es = Elasticsearch('https://localhost:9200')

# Document 1
>>> es.index(index='test', id=1, body={'text': 'testing elasticsearch connection'})

# Document 2
>>> es.index(index='test', id=2, body={'text': 'this is another test'})
```

Above, we have written two documents with the index `test` each with a field called `text`. Let us try to search for the word `test` as seen in the body of each document. 

```python
>>> es.search(index='test', body={'query': {'match': {'text': 'test'}}})
```

The response from the `es.search()` call is a Python dictionary whose results are:

```python
{
    'took': 16, 
    'timed_out': False, 
    '_shards': {
        'total': 1, 
        'successful': 1, 
        'skipped': 0, 
        'failed': 0
        }, 
    'hits': {
        'total': {
            'value': 1, 
            'relation': 'eq'
            }, 
        'max_score': 0.6548753, 
        'hits': [
                {
                    '_index': 'test', 
                    '_type': '_doc', 
                    '_id': '2', 
                    '_score': 0.6548753, 
                    '_source': {'text': 'this is another test'}
                }
            ]
        }
    }
```

The results query returned one document with a non-perfect score. A perfect score is 1. The returned document is the one that contains our search word. Typically, if there is more than one document, the one with the highest score is the one that contains almost the exact words searched for. Those that partially contain the words would be returned but with a lower score. To delete an index, you can run:

```python
>>> es.indices.delete('test')
```

## Configure Elasticsearch

Like with other configurations, the connection URL for Elasticsearch is going to be sourced form an environemnt variable. 

```python
# config.py: Configure Elasticsearch

class Config(object):
    # ...

    ELASTICSEARCH_URL = os.environ.get('ELASTICSEARCH_URL')
```

If this variable is not defined, we are going to set it to `None` and use it as a signal to disconnect Elasticsearch. In certain situations, say during unit testing, we may not necessarily need Elasticsearch to run, and therefore, disabling it may come in handy. To instatiate this variable, we will need to update the `.env` file as follows:

```python
# .env: Elasticsearch URL

ELASTICSEARCH_URL=http:localhost:9200
```

The challenge with working with Elasticsearch is that it is not wrapped by a Flask extension, and cannot be initalized in a global scope as many other extensions. The only way to access this variable is through `app.config` which becomes available once a Flask context is created.

If you are not working with a factory function, then there is not much to do here since your application's instance will have access to the `config` module:

```python
#app/__init__.py: Access configurations

from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from config import Config
from flask_bootstrap import Bootstrap
from flask_moment import Moment


app = Flask(__name__)
app.config.from_object(Config)      # < --- access environment variables

# Variables on a global scope
db = SQLAlchemy(app)
migrate = Migrate(app, db, render_as_batch=True)
bootstrap = Bootstrap(app)
moment = Moment(app)


from app import routes, models

```

However, if you are using blueprints and a factory function, Elasticsearch configurations will only be accessbile once `create_app()` function has been invoked.

```python
# app/__init__.py: Elasticsearch with a factory function

# ...
from elasticsearch import Elasticsearch
# ...

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    app.elasticsearch = Elasticsearch([app.config['ELASTICSEARCH_URL']]) \
        if app.config['app.config['ELASTICSEARCH_URL']'] else None
```

